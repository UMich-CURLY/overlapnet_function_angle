try: from utils import *
except: from utils import *
from se_kernel_geo import se_kernel_geo
import csv
from tqdm import tqdm

def function_angle_range(reference_range, refrence_pose, current_range, current_pose, valid_num):
  """Compute function angle from range vertex
     Input: 
        
     Returns: 
        cos(function angle)
  """
  
  # se_kernel
  A_sum, A_valid, num_two_points = se_kernel_geo(reference_range, current_range)
  
  # normalize
  cos_angle = A_sum / np.sqrt(num_two_points)

  return cos_angle


def function_angle_scan(X, Z):
  """Compute function angle from LiDAR scans
     Input: 
        X is the points_reference, points are already transformed to current_points' frame
        Z is the current_points, A nx4 numpy array of homogeneous points (x, y, z, 1)
     Returns: 
        cos(function angle)
  """
  # print('X', X.shape)
  # print('Z', Z.shape)

  # se_kernel
  num_two_points = X.shape[0] * Z.shape[0]
  A_sum, A_valid = se_kernel_geo(X, Z)

  # normalize, approximate way
  function_angle = A_sum / np.sqrt(num_two_points)

  # real inner product
  # fxfz, _, _ = se_kernel_geo(points_reference, current_points)
  # fx_norm, _, _ = np.sqrt(se_kernel_geo(X, X))
  # fz_norm, _, _ = np.sqrt(se_kernel_geo(Z, Z))
  # cosine_value = A_sum / (fx_norm * fz_norm)

  print('function_angle = %.4f, cosine_value = %.4f' % (function_angle, cosine_value))
  
  return function_angle

def com_function_angle(scan_paths, poses, frame_idx, leg_output_width=360):
  """compute the function angle and yaw ground truth from the ground truth poses,
     which is used for OverlapNet training and testing.
     Args:
       scan_paths: paths of all raw LiDAR scans
       poses: ground-truth poses either given by the dataset or generated by SLAM or odometry
       frame_idx: the current frame index
     Returns:
       ground_truth_mapping: the ground truth overlap and yaw used for training OverlapNet,
                             where each row contains [current_frame_idx, reference_frame_idx, overlap, yaw]
  """
  # init ground truth overlap and yaw
  print('Start to compute ground truth overlap and yaw ...')
  function_angles = []
  yaw_idxs = []
  yaw_resolution = leg_output_width
  
  # we calculate the ground truth for one given frame only
  # generate range projection for the given frame
  current_points = load_vertex(scan_paths[frame_idx])
  current_range, project_points, current_intensity, current_idx = range_projection(current_points)
  visible_points = project_points[current_range > 0]
  valid_num = len(visible_points)
  current_pose = poses[frame_idx]
  visible_points_world = current_pose.dot(visible_points.T).T

  # read function_angle from saved csv file
  with open('/home/cel/CURLY/code/DockerFolder/data/kitti/sequences/07_overlap/preprocess_data_demo/07_0.csv', newline='') as csvfile:
    spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
    for row in spamreader:
      _, function_angle = row
      function_angles.append(function_angle)

  for refrence_idx in range(len(scan_paths)):
    # print('\n===============\nrefrence_idx:', refrence_idx)
    # generate range projection for the reference frame
    refrence_pose = poses[refrence_idx]
    points_reference = np.linalg.inv(refrence_pose).dot(visible_points_world.T).T
    reference_range, reference_points, reference_intensity, reference_idx = range_projection(points_reference)
    
    # calculate overlap to compare the result
    # overlap = np.count_nonzero(
    #   abs(reference_range[reference_range > 0] - current_range[reference_range > 0]) < 1) / valid_num
   
    # calculate function_angle from scan
    # function_angle = function_angle_scan(reference_points[reference_range > 0], visible_points)
    # function_angles.append(function_angle)
    
    # calculate yaw angle
    relative_transform = np.linalg.inv(current_pose).dot(refrence_pose)
    relative_rotation = relative_transform[:3, :3]
    _, _, yaw = euler_angles_from_rotation_matrix(relative_rotation)

    # discretize yaw angle and shift the 0 degree to the center to make the network easy to lean
    yaw_element_idx = int(- (yaw / np.pi) * yaw_resolution//2 + yaw_resolution//2)
    yaw_idxs.append(yaw_element_idx)

    # print('finished pair id: ', refrence_idx)
  
  # ground truth format: each row contains [current_frame_idx, reference_frame_idx, function_angles, yaw]
  ground_truth_mapping = np.zeros((len(scan_paths), 4))
  ground_truth_mapping[:, 0] = np.ones(len(scan_paths)) * frame_idx
  ground_truth_mapping[:, 1] = np.arange(len(scan_paths))
  ground_truth_mapping[:, 2] = function_angles
  ground_truth_mapping[:, 3] = yaw_idxs
  
  print('Finish generating ground_truth_mapping!')
  
  return ground_truth_mapping

def read_function_angle_com_yaw(scan_paths, poses, funcangle_file, leg_output_width=360):
  """compute the function angle and yaw ground truth from the ground truth poses,
     which is used for OverlapNet training and testing.
     Args:
       scan_paths: paths of all raw LiDAR scans
       poses: ground-truth poses either given by the dataset or generated by SLAM or odometry
       frame_idx: the current frame index
     Returns:
       ground_truth_mapping: the ground truth overlap and yaw used for training OverlapNet,
                             where each row contains [current_frame_idx, reference_frame_idx, overlap, yaw]
  """
  # init ground truth overlap and yaw
  print('Start to compute ground truth overlap and yaw ...')
  frame_idx_1 = []
  frmae_idx_2 = []
  function_angles = []
  yaw_idxs = []
  yaw_resolution = leg_output_width
  
  # read function_angle from saved csv file
  for input_file in funcangle_file:
    with open(input_file, newline='') as csvfile:
      spamreader = csv.reader(csvfile, delimiter='\t', quotechar='|')
      for row in spamreader:
        if len(row) == 1:
          spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
        break
      for row in spamreader:
        if len(row) == 1:
          spamreader = csv.reader(csvfile, delimiter=',', quotechar='|')
        break
      for row in spamreader:
        print('row', row)
        idx_1, idx_2, function_angle = row
        frame_idx_1.append(int(idx_1))
        frmae_idx_2.append(int(idx_2))
        function_angles.append(float(function_angle))

  for idx in tqdm(range(len(function_angles))):
    frame_idx = frame_idx_1[idx]
    refrence_idx = frmae_idx_2[idx]
    
    # get pose
    current_pose = poses[frame_idx]
    refrence_pose = poses[refrence_idx]
    
    # calculate yaw angle
    relative_transform = np.linalg.inv(current_pose).dot(refrence_pose)
    relative_rotation = relative_transform[:3, :3]
    _, _, yaw = euler_angles_from_rotation_matrix(relative_rotation)

    # discretize yaw angle and shift the 0 degree to the center to make the network easy to lean
    yaw_element_idx = int(- (yaw / np.pi) * yaw_resolution//2 + yaw_resolution//2)
    yaw_idxs.append(yaw_element_idx)

  
  # ground truth format: each row contains [current_frame_idx, reference_frame_idx, function_angles, yaw]
  ground_truth_mapping = np.zeros((len(function_angles), 4))
  ground_truth_mapping[:, 0] = frame_idx_1
  ground_truth_mapping[:, 1] = frmae_idx_2
  ground_truth_mapping[:, 2] = function_angles
  ground_truth_mapping[:, 3] = yaw_idxs
  
  print('Finish generating ground_truth_mapping!')
  
  return ground_truth_mapping


def read_function_angle_com_overlap_yaw(scan_paths, poses, funcangle_file, leg_output_width=360):
  """read the function angle value from csv file and compute overlap value and yaw ground truth from the ground truth poses,
     which is used for OverlapNet training and testing.
     Args:
       scan_paths: paths of all raw LiDAR scans
       poses: ground-truth poses either given by the dataset or generated by SLAM or odometry
       frame_idx: the current frame index
     Returns:
       ground_truth_mapping: the ground truth overlap and yaw used for training OverlapNet,
                             where each row contains [current_frame_idx, reference_frame_idx, overlap, yaw]
  """
  # init ground truth overlap and yaw
  print('Start to compute ground truth overlap and yaw ...')
  frame_idx_1 = []
  frmae_idx_2 = []
  function_angles = []
  overlaps = []
  yaw_idxs = []
  yaw_resolution = leg_output_width
  
  # read function_angle from saved csv file
  with open(funcangle_file, newline='') as csvfile:
    spamreader = csv.reader(csvfile, delimiter='\t', quotechar='|')
    # spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
    for row in spamreader:
      # print('row', row)
      idx_1, idx_2, function_angle = row
      frame_idx_1.append(int(idx_1))
      frmae_idx_2.append(int(idx_2))
      function_angles.append(float(function_angle))

  for idx in tqdm(range(len(function_angles))):
    frame_idx = frame_idx_1[idx]
    reference_idx = frmae_idx_2[idx]
    
    # get pose
    current_pose = poses[frame_idx]
    reference_pose = poses[reference_idx]
    
    # generate range projection for the given frame
    current_points = load_vertex(scan_paths[frame_idx])
    current_range, project_points, _, _ = range_projection(current_points)
    visible_points = project_points[current_range > 0]
    valid_num = len(visible_points)

    # generate range projection for the reference frame
    reference_points = load_vertex(scan_paths[reference_idx])
    reference_points_world = reference_pose.dot(reference_points.T).T
    reference_points_in_current = np.linalg.inv(current_pose).dot(reference_points_world.T).T
    reference_range, _, _, _ = range_projection(reference_points_in_current)

    # calculate overlap
    overlap = np.count_nonzero(
      abs(reference_range[reference_range > 0] - current_range[reference_range > 0]) < 1) / valid_num
    overlaps.append(overlap)
    
    # calculate yaw angle
    relative_transform = np.linalg.inv(current_pose).dot(reference_pose)
    relative_rotation = relative_transform[:3, :3]
    _, _, yaw = euler_angles_from_rotation_matrix(relative_rotation)

    # discretize yaw angle and shift the 0 degree to the center to make the network easy to lean
    yaw_element_idx = int(- (yaw / np.pi) * yaw_resolution//2 + yaw_resolution//2)
    yaw_idxs.append(yaw_element_idx)

  
  # ground truth format: each row contains [current_frame_idx, reference_frame_idx, function_angles, yaw]
  ground_truth_mapping = np.zeros((len(function_angles), 5))
  ground_truth_mapping[:, 0] = frame_idx_1
  ground_truth_mapping[:, 1] = frmae_idx_2
  ground_truth_mapping[:, 2] = overlaps
  ground_truth_mapping[:, 3] = function_angles
  ground_truth_mapping[:, 4] = yaw_idxs
  
  print('Finish generating ground_truth_mapping!')
  
  return ground_truth_mapping
